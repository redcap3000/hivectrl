<!DOCTYPE html>
<html>
    <head>
		<title>Cryptoez</title>
	    <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
         <script src="https://d3js.org/d3-color.v1.min.js"></script>
        <script src="https://d3js.org/d3-interpolate.v1.min.js"></script>
        <script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="stylesheet" href="/styles.css"/>
    </head>
    <body>
    <div id="topBar">
        <div class="hiveContainer" id="hiveHashrateData"></div>
        <div class="hiveContainer" id="hiveFarmData"></div>

            <div id="openWeatherData"></div>             
    <div id="openWeatherData2"></div>
    </div>


    
    <div class="hiveContainer" id="hiveWorkersData"></div>

    
    <div class="dev" id="colorRefScale"></div>
    <div class="hiveContainer" id="hiveSelectedWorkerId">
        </div>
        <div class="hiveContainer" id="hiveSelectedCard">
        </div>
        <div class="hiveContainer" id="hiveSelectedIdxs">
        </div>
        <!-- <button onClick="getHiveFlightsheets()">Get Flightsheets</button> -->
        <div class="hiveContainer" id="hiveFlightsheets">
        </div>
        <script>  
            function getDeviceIndexPrefix(miner,devices){
                // miner = 'ccminer'
                // devices = [0,1,2,3]
                var crossRX = {
                    'mtp' : 'cryptodredge',
                    'cuckaroo29s' : 'gminer',
                    'x16rv2' : 'trex',
                    // beam
                    '150_5': 'gminer'
                }
                if(typeof crossRX[miner] != 'undefined'){
                    miner = crossRX[miner]
                }
                var prefixes = {
                    'ccminer' : ['-d',' '],
                    'gminer' : ['--devices',' '],
                    'trex' : ['"devices": "',',','"'],
                    'cryptodredge' : ['-d',',']
                }
                if(typeof prefixes[miner] != 'undefined'){
                    prefixes = prefixes[miner]
                    if(prefixes.length == 3){
                        // this is a json type, the last element is what to end the line with
                        // aka json
                        return prefixes[0] +  devices.join(prefixes[1]) +prefixes[2]
                    }else{
                        return prefixes[0] + ' ' + devices.join(prefixes[1]) 
                        // most other configurations
                    }
                }
                return false
            }
            function getDeviceSeperator(miner){
                // for seperating the devices, could be ' ' or usually ','
            }          
            function returnCoinImgPath(coin){
                if(typeof coin != 'undefined'){
                    return '<img src="https://the.hiveos.farm/icons/'+coin.toLowerCase()+'.png" alt="" class="coinImg">'
                }else{
                    return ''
                }
            }
            function d3ColorCodeNegative(percent){
                percent = parseFloat(percent)
                if(percent  < 0){
                   colorCode = d3.interpolateOrRd(Math.abs(percent/100))
                }else{
                    colorCode = d3.interpolateYlGn(percent/100)
                }
                return colorCode
            }
            function d3ColorCodeSimple(aFloat){
                return d3.interpolateGreens(aFloat/10)
                
            }
            function d3ColorCodeHour(aFloat){
                return d3.interpolatePiYG(aFloat/24)
                
            }
            // for values like fan speeds, higher is red, lower is blue mids are green/yellow
            function d3ColorCodeInverse(percent){
                percent = parseFloat(percent)
                return d3.interpolateTurbo(percent/100)
            }
            // for temperatures blues are cold red are warm
            function d3ColorCodeTemp(percent){
                percent = parseFloat(percent)
                return d3.interpolatePuOr(percent/100)
                   
            }
            // for basic white-greens for stuff like hashrates
            function d3ColorCodeS(percent){
                percent = parseFloat(percent)
            
                return d3.interpolateGreens( ( percent/100 ) )
            }

            function d3ColorCodePwrHash(val){
                if(val > 3 && val < 6){
                    // arbitrary will have to analyize all values in the list to make a real color scale from
                    // highest hash rate/power to lowest
                    // this is probably eth hash (I HOPE)
                    return d3.interpolateGreens( ( val/3.95 ) )
                    
                }else{
                    // take a best guess that the value is an integer?
                    return d3.interpolateGreens( ( val/5 ) )
                }
            }
             function d3ColorCodeP(percent){
                percent = parseFloat(percent)
                return d3.interpolateGreens(percent/100000)
            }
            // for clouds
             function d3ColorCodeC(percent){
                percent = parseFloat(percent)
                return d3.interpolateGreys(percent/100)
            }
            function d3ColorCodeDirection(degrees){
                return d3.interpolateViridis(degrees/360  )
                
            }
            var rigs = {}
            var getData = true
            var dataInt = false
            var selectedCardIdxs=[]
            var selectedWorkerId=0
            var selectedCard=''
            function writeToDom(id,data){
                var docElement = document.getElementById(id)
                docElement.innerHTML=''
                if(typeof data != 'undefined' && typeof data.filter == 'function'){
                    data.filter(function(o){
                        docElement.innerHTML += o
                    })   
                }else{
                    if(typeof data != 'undefined'){
                        docElement.innerHTML = data
                    }
                }
            }
            function colorRefScale(){
                var step = 5
                var count = 1
                var r = []
                while(count < 100/step){
                    var style = 'background-color:'+d3ColorCodeInverse(step * count)+';'
                    r.push('<div style="'+style+'">'+step*count+'</div>')
                    count++
                }
                writeToDom('colorRefScale',r)
            }
            function convertHashrate(num,showRate){
                var hrate_check = parseFloat(num)
                if(!hrate_check){
                    return false
                }
                if(hrate_check < 1.0){
                    hr =(hrate_check*1000).toFixed(2) + (typeof showRate != 'undefined'? ' h/s':'') 
                }else if(hrate_check > 1000){
                    hr =(hrate_check/1000).toFixed(3) + (typeof showRate != 'undefined'? ' kh/s':'')
                }else if(hrate_check > 10000){
                    hr =(hrate_check/10000).toFixed(4) + (typeof showRate != 'undefined'? ' mh/s':'') 
                }
                if(typeof hr != 'undefined'){
                    return hr
                }else{
                    return Number(0)
                }
            }
            hisHash={}
            unixTS_to_date= function(unix_timestamp){
                var date = new Date(unix_timestamp * 1000);
                // Hours part from the timestamp
                var hours = date.getHours();
                // Minutes part from the timestamp
                var minutes = "0" + date.getMinutes();
                // Seconds part from the timestamp
                var seconds = "0" + date.getSeconds();
                // Will display time in 10:30:23 format
                var formattedTime = hours + ':' + minutes.substr(-2) + ':' + seconds.substr(-2);
                return formattedTime
            }
            kelvinToFahrenheit = function(k){
                k = parseFloat(k)
                k = k - 273.15
                return Math.floor(k * (9/5) + 32);
            }
            getHiveData = function(){
                var endPoint = '/api'
                $.getJSON(endPoint,function(data){
                    if(typeof data != 'undefined'){
                        var minerStats= data.minerstats
                        /*
                            {467468: Array(2)}467468: Array(2)0: algo: "cuckaroo29s"bus_numbers: (6) [1, 4, 5, 12, 13, 16]coin: "XWP"fans: (6) [33, 26, 38, 26, 22, 22]hashes: (6) [0.0046500000000000005, 0.00319, 0.00459, 0.00309, 0.00316, 0.00315]miner: "gminer"temps: (6) [62, 66, 63, 66, 64, 64]__proto__: Object1: {miner: "cryptodredge", algo: "mtp", coin: "XZC", hashes: Array(5), temps: Array(5), …}length: 2__proto__: Array(0)__proto__: Object

                        */
                        // reform minerStats for easier referencing ?
                        var minerStatsRef={}
                        var hashratesByCoinRef={}
                        for(var farm in data.farms){
                            var minerStats_digest=['<ul>']
                            var miners_stats =[]
                             for(var workerId in minerStats){
                                var miners = minerStats[workerId]
                                miners.filter(function(w){
                                    if(typeof minerStatsRef[workerId] == 'undefined'){
                                        minerStatsRef[workerId] ={}
                                    }
                                    var minerWorkerGuid=w.miner+'_'+w.algo+'_'+w.coin
                                    if(typeof minerStatsRef[workerId][w.miner] == 'undefined'){

                                    }
                                    var concatDatas=[]
                                    function busFilter(b,i){
                                        var b2 = b+''
                                        var row = {
                                            workerId : workerId,
                                            bus_number : b,
                                            fans : w.fans[i],
                                            hashes: w.hashes[i],
                                            temps : w.temps[i],
                                            algo : w.algo,
                                            coin : w.coin
                                        }
                                       if(typeof hisHash[workerId+''] == 'undefined'){
                                            hisHash[workerId+'']={}
                                       }
                                       if(typeof hisHash[workerId+''][b+''] == 'undefined'){
                                            hisHash[workerId+''][b+'']=[]
                                       }
                                       if(w.hashes[i] != hisHash[workerId+''][b+''][hisHash[workerId+''][b+''].length-1]){
                                            hisHash[workerId+''][b+''].push(w.hashes[i])
                                        }
                                        if(typeof miners_stats[workerId] == 'undefined'){
                                            miners_stats[workerId] = {}
                                        }
                                        if(typeof miners_stats[workerId][b2] == 'undefined'){
                                            miners_stats[workerId][b2] ={}
                                        }
                                        miners_stats[workerId][b2]=row
                                    }
                                    if(typeof w.bus_numbers != 'undefined'){
                                        w.bus_numbers.filter(busFilter)
                                    }else if(typeof w.bus_number != 'undefined'){
                                        busFilter(parseInt(w.bus_number),0)
                                        // bus numbers not provided
                                    }else{
                                        if(typeof w.hashes != 'undefined'){
                                            // use index as busid
                                            var c = 0
                                            while(c< w.hashes.length){
                                                var c2 = c+''
                                                var row={
                                                    workerId : workerId,
                                                    bus_number : c,
                                                    fans : w.fans[c],
                                                    hashes: w.hashes[c],
                                                    temps : w.temps[c],
                                                    algo : w.algo,
                                                    coin : w.coin
                                                }
                                                if(typeof hisHash[workerId+''] == 'undefined'){
                                                    hisHash[workerId+'']={}
                                                }
                                                if(typeof hisHash[workerId+''][c+''] == 'undefined'){
                                                    hisHash[workerId+''][c+'']=[]
                                                }
                                                if(w.hashes[c] != hisHash[workerId+''][c+''][hisHash[workerId+''][c+''].length-1]){
                                                    hisHash[workerId+''][c+''].push(w.hashes[c])
                                                }
                                                if(typeof miners_stats[workerId] == 'undefined'){
                                                    miners_stats[workerId] = {}
                                                }
                                                if(typeof miners_stats[workerId][c2] == 'undefined'){
                                                    miners_stats[workerId][c2] ={}
                                                }
                                                miners_stats[workerId][c2]=row
                                                c++
                                            }
                                        }
                                        // some miners like xmr dont provide bus numbers for whatever reason so use a different field and count index
                                    }
                                })
                            }
                            var output=['<ul>']
                            var f = data.farms[farm]
                            var fieldsNames=[
                              //  'Idle Power Draw',
                                'Name',
                                //'Price/Watt',
                                'Total Rigs',
                                'Online',
                                //'Tz',
                            ]
                            var values = [
                         //   f.hardware_power_draw,
                            f.name,
                            //f.power_price,
                            f.rigs_count,
                            f.stats.workers_online,
                            //f.timezone
                            //f.hashrates_by_coin.coin,
                            //f.hashrates_by_coin.algo,
                            //f.hashrates_by_coin.hashrate
                            ]
                            values.filter(function(val,idx){
                                var keyName = fieldsNames[idx]
                                // hacky stuff for shorten display output
                                if(keyName == 'Name'){
                                    output.push('<li><h4>')
                                }
                                output.push( (keyName != 'Name' && keyName != 'Tz' && keyName != 'Online' ? keyName + ' : ' : (keyName == 'Online' ? '/' : ' '))+' ' +val )
                                if(keyName == 'Tz'){
                                    output.push('</h4></li>')
                                }
                                
                            })
                            //output.push(' ')
                            if(output.length > 2){
                                writeToDom('hiveFarmData',output.join(' '))
                            }
                            if(typeof f !='undefined' && typeof f.hashrates_by_coin != 'undefined'){
                                var hashrates_by_coin=['<table class="hrByCoin"><tbody>']
                                f.hashrates_by_coin.filter(function(hr){
                                    console.log(hr)
                                    var hrate_check = parseFloat(hr.hashrate)
                                    if(hrate_check < 1.0){
                                        hr.hashrate =(hrate_check*1000).toFixed(2) + ' h/s' 
                                    }else if(hrate_check > 1000){
                                        hr.hashrate =(hrate_check/1000).toFixed(3) + ' kh/s' 
                                    }else if(hrate_check > 10000){
                                        hr.hashrate =(hrate_check/10000).toFixed(4) + ' mh/s' 
                                    }else if(!hrate_check){
                                        return false
                                    }
                                    hashrates_by_coin.push("<tr><td>"+ returnCoinImgPath(hr.coin) + '</td><td>' + hr.algo + ' @ ' + hr.hashrate + "</td></tr>")
                                    if(typeof hashratesByCoinRef[hr.algo] == 'undefined'){
                                        hashratesByCoinRef[hr.algo] = {}
                                    }
                                    if(typeof hashratesByCoinRef[hr.algo][hr.coin] == 'undefined'){
                                        hashratesByCoinRef[hr.algo][hr.coin]=hr.hashrate
                                    }
                                })
                                hashrates_by_coin.push('</tbody></table>')
                            }
                            var workers_digest=[]
                            var workers_ref={}
                            var workerClickGuids = []
                            // reorder/ remove workers without reporting GPU's? workers
                            // tie into interface option to support showing/hiding offline rigs
                            var reOrder={}
                            for(var wId in f.workers){
                                theWorker = f.workers[wId]
                                if(typeof miners_stats[wId] != 'undefined'){
                                    reOrder[wId]={}
                                    reOrder[wId]=f.workers[wId]
                                }
                                //console.log(theWorker)
                            }
                            //if(reOrder.length !== f.workers.length){
                            f.workers=reOrder
                            //}
                            for(var workerId in f.workers){
                                var theWorker = f.workers[workerId]
                                workers_digest.push('<h3>'+workerId+'</h3>')
                                for(var gpuModel in theWorker.gpus){
                                    var wrk = theWorker.gpus[gpuModel]
                                    // need to cross reference workerId here..
                                    var domGuid = 'w-'+workerId
                                    // generate guid from gpu indexes
                                    // also check for identical algo kind to append the info to model instead of dom
                                    wrk.filter(function(ww){
                                        domGuid += '_'+ww.idx
                                    })
                                    //workers_digest.push('<h4 id="'+domGuid+'">' + gpuModel + '</h4>')
                                    //attach click handler
                                    workerClickGuids.push(domGuid)
                                    // prefilter to generate the colorcoding grading based on the nearby cards?
                                    /*

                                        MAKE NEW CHART TO TRACK POWER 

                                    */
                                    wrk.filter(function(w){
                                        var cardStats=undefined
                                        if(typeof miners_stats[workerId] != 'undefined' && typeof miners_stats[workerId][w.bus_number+''] != 'undefined'){
                                            // WORKER HASH|RATE VISUALISATION THINGEE AROUND HERE
                                            cardStats = miners_stats[workerId][w.bus_number+'']
                                            var cHashRate=convertHashrate(cardStats.hashes,true)
                                            var cHashRateString = convertHashrate(cardStats.temps)
                                            var cTemp = w.power/parseFloat(convertHashrate(cardStats.hashes))

                                            // divide power by rate?

                                            var fanStyle = 'background-color:'+d3ColorCodeInverse(cardStats.fans)+';'
                                            if(typeof hashratesByCoinRef[cardStats.algo] != 'undefined' && typeof hashratesByCoinRef[cardStats.algo][cardStats.coin] != 'undefined'){
                                                // this is terrible.fix
                                                if(typeof hashratesByCoinRef[cardStats.algo][cardStats.coin].split == 'function'){
                                                    var totalSpeed = hashratesByCoinRef[cardStats.algo][cardStats.coin].split(' ')[0]
                                                    if(typeof totalSpeed != 'undefined' && totalSpeed){
                                                        totalSpeed = parseFloat(totalSpeed)
                                                        var adjustedColor = (totalSpeed/cHashRate) * wrk.length
                                                    }else{
                                                        var adjustedColor = cHashRate
                                                    }
                                                    //var hashrateStyle = 'background-color:'+d3ColorCodeS(adjustedColor)+';'
                                                    // probably get values from some kind of max/min temp to express
                                                    // the relationship a bit better than this....   
                                                    var hashrateStyle = 'background-color:'+d3ColorCodeInverse(cHashRate)+';'
                                                }
                                            }else{
                                                var hashrateStyle = 'background-color:none;'
                                            }
                                            if(typeof cTemp != 'undefined'){
                                                var cTempStyle='background-color:'+d3ColorCodeInverse(cTemp*15)+';'
                                            }else{
                                                var cTempStyle=''
                                            }
                                            var historicalHashrates='<tr><td colspan="4">'
                                            if(typeof hisHash[workerId] != 'undefined' && typeof hisHash[workerId][w.bus_number+''] != 'undefined'){
                                                var hh = hisHash[workerId][w.bus_number+'']
                                                 function percIncrease(a, b) {
                                                    let percent;
                                                    a = parseFloat(a)
                                                    b = parseFloat(b)
                                                    if(b !== 0) {
                                                        if(a !== 0) {
                                                            percent = (b - a) / a * 100;
                                                        } else {
                                                            percent = b * 100;
                                                        }
                                                    } else {
                                                        percent = - a * 100;            
                                                    }       
                                                    return Math.floor(percent);
                                                }
                                                // keep the number of elements in hh to 50
                                                var shouldShift = false
                                                hh.filter(function(hashrate,i){
                                                    if(i < 50){
                                                        var perIn= (i > 1 ? percIncrease(convertHashrate(hashrate),convertHashrate(hh[i-1])) : 0)
                                                        var hrStyle = d3ColorCodeNegative(convertHashrate(hashrate) * perIn)
                                                        historicalHashrates += "<div class='hhBox' style='background-color:"+hrStyle+";'>&nbsp;</div>"
                                                    }else{
                                                        // clear ?
                                                        // OVERFLOW?
                                                        shouldShift = true
                                                    }
                                                })
                                                if(shouldShift){
                                                    hh.shift()
                                                }else{
                                                }
                                                historicalHashrates += "</td></tr>"
                                            }
                                            workers_digest.push(
                                                '<table><tbody><tr>'+
                                                //returnCoinImgPath(cardStats.coin)+
                                                //'</td><td><small>'+
                                                 // w.idx+ ' : <span>' + cardStats.algo+ ' @ '+
                                               
                                                // cHashRateString + '</span>'+
                                                //'</small></td>
                                                '<td  class="wrk_temp" style="'+
                                                cTempStyle+'"></td><td class="wrk_fans" style="'+
                                                fanStyle+'">&nbsp;</td><td class="wrk_algo_info" style="'+
                                                hashrateStyle+'">&nbsp;</td></tr>'+
                                                historicalHashrates
                                                +'</tbody></table>')

                                        }else{
                                            //workers_digest.push('<ul><li><span>'+w.idx+'</span></li></ul>')
                                        }
                                        // fans hashes temps
                                        // for combining with data below
                                        if(typeof workers_ref[workerId] == 'undefined'){
                                            workers_ref[workerId]={}
                                        }
                                        if(typeof workers_ref[workerId][w.bus_number] == 'undefined'){
                                            workers_ref[workerId][w.bus_number]={}
                                        }
                                        // data to pass/ref
                                        workers_ref[workerId][w.bus_number]=gpuModel
                                    })
                                }
                                 // workers_digest.push('</ul>')
                            }
                        }
                       
                        if(typeof hashrates_by_coin != 'undefined'){
                            if(hashrates_by_coin.length > 2){
                                writeToDom('hiveHashrateData',hashrates_by_coin.join('\n'))
                            }
                        }
                        if(workers_digest.length > 2){
                            var docElement = document.getElementById('hiveWorkersData')
                            docElement.innerHTML=''
                            workers_digest.filter(function(o){
                                docElement.innerHTML += o
                            })
                            writeToDom('hiveWorkersData',workers_digest)
                            /*
                            if(workerClickGuids.length > 0){
                                workerClickGuids.filter(function(wrkr){
                                    document.getElementById(wrkr).addEventListener("click",function(){
                                        var idxs= wrkr.split('_')
                                        var workerId=idxs.shift()
                                        selectedCard= this.innerHTML.trim('')
                                        selectedCardIdxs=idxs
                                        selectedWorkerId=workerId.split('-')[1]
                                        // these are the indexes.. 
                                    })
                                })
                            }
                            */
                        }
                    }
                })
            }
            getOpenWeather = function(){
                let endPoint = '/openWeather'
                $.getJSON(endPoint,function(data){
                    if(typeof data == 'object' && data){
                        let current = (typeof data.current != 'undefined'?data.current : false)
                        let currentHourly = (typeof data.hourly != 'undefined' ? data.hourly : false)
                        let currentDaily = (typeof data.daily != 'undefined' ? data.daily : false)
                        let currentString = ['<ul>']
                        if(current){
                            for(var k in current){
                                if(typeof current[k] == 'object' && typeof current[k].filter == 'function'){
                                    // array with objects
                                    current[k].filter(function(o){
                                        for(var k2 in o){
                                              currentString.push('<li>'+k2+ o[k2]+'</li>') 
                                        }
                                    })
                                }else if(typeof current[k] == 'string' || typeof current[k] == 'number'){
                                    if(['dt','sunrise','sunset'].indexOf(k) > -1){
                                        currentString.push('<li>'+k+' '+unixTS_to_date(current[k])+'</li>')
                                    
                                    }else if(['temp','feels_like','dew_point'].indexOf(k) > -1){
                                         currentString.push('<li>'+k+' '+kelvinToFahrenheit(current[k])+'</li>')
                                    }else{
                                        currentString.push('<li>'+k+' '+current[k]+'</li>')
                                    }
                                }
                            }                            
                            currentString.push('</ul>')
                        }
                        let rString = '<table><tbody>'
                        if(typeof currentHourly != 'undefined'){
                            //let currentHourlyString  = ''
                            currentHourly.filter(function(o,x){
                                // dt,temp,feels_like,pressure,humidity,temp,weather,wind_deg,wind_speed
                                let obj = {}
                                let temps = ['temp','feels_like','temp','dew_point']
                                for(var k in o){
                                    let s = '<li>'
                                    if(k == 'dt'){
                                        s += unixTS_to_date(o[k])
                                        obj.date = unixTS_to_date(o[k])
                                    }else if(temps.indexOf(k) > -1){
                                        // temps
                                        s += k+ ' : '+kelvinToFahrenheit(o[k])
                                        obj[k] = ''
                                        obj[k] = kelvinToFahrenheit(o[k])
                                    }else if(k == 'weather'){
                                        // todo word images for current conditions
                                    }else{
                                        obj[k] = o[k]
                                        s += k + ' ' + o[k]
                                    }
                                    s+='</li>'
                                    //currentHourlyString += s
                                }
                                if(typeof obj.wind_speed != 'undefined'){
                                    let n = []
                                    for(var k2 in obj){
                                        if(k2 == 'temp' || k2 == 'feels_like' || k2 == 'dew_point'){
                                            n.push("<td style='background-color:"+d3ColorCodeTemp(obj[k2])+";'></td>")
                                        }else if(k2 == 'wind_speed'){
                                            n.push("<td style='background-color:"+d3ColorCodeSimple(obj[k2])+";'></td>")
                                        }else if(k2 == 'clouds'){
                                            n.push("<td style='background-color:"+d3ColorCodeC(obj[k2])+";'></td>")
                                        }else if(k2 == 'humidity'){
                                            n.push("<td style='background-color:"+d3ColorCodeTemp(obj[k2])+";'></td>")
                                        }else if(k2 == 'pressure'){
                                              //n += "<td style='background-color:"+d3ColorCodeP(obj[k2])+";'>"
                                        }else if(k2 == 'wind_deg'){
                                            n.push("<td style='background-color:"+d3ColorCodeDirection(obj[k2])+";'></td>")
                                           // n.push("<td>"+obj[k2]+"</td>")
                                        }else if(k2 == 'date'){
                                            // convert time into color?
                                            var time = obj[k2].split(':').shift()
                                            n.push("<td style='background-color:"+d3ColorCodeHour(time)+";'></td>")
                                        }
                                    }
                                    // perform rearrange
                                    n.unshift('<tr style="height:5px;">')
                                    n.push('</tr>')
                                    rString+=n.join('\n')
                                }
                            })
                        }
                        writeToDom('openWeatherData',rString)

                        if(typeof currentDaily != 'undefined' && currentDaily){
                            // todo for real.... 
                            return false
                            let currentDailyR = ['<table><thead><tr><th></th><th>rise</th><th>set</th><th>temps</th><th>feels like</th><th>pressure</th><th>humidity</th><th>dew point</th><th>wind speed</th><th>wind direction</th><th>clouds</th></tr></thead><tbody>']
                            currentDaily.filter(function(o,x){
                                // dt,temp,feels_like,pressure,humidity,temp,weather,wind_deg,wind_speed
                                let obj = {}
                                let temps = ['temp','feels_like','temp','dew_point']
                                let tempsI = ['day','min','max','night','eve','morn']
                                for(var k in o){
                                    let s = '<td>'
                                    if(k == 'dt' || k == 'sunrise' || k == 'sunset'){
                                        if(k != 'dt'){
                                            s += unixTS_to_date(o[k])
                                            obj.date = unixTS_to_date(o[k])
                                        }
                                    }else if(temps.indexOf(k) > -1){
                                        // temps
                                        console.log(o[k])
                                        if(typeof o[k] == 'object'){
                                            let dailyTemps = o[k]
                                            if(x === 0 ){
                                                var innerTable = ['<table class="iTable"><thead><tr><th>day</th><th>eve</th><th>morn</th><th>night</th>']
                                                if(typeof dailyTemps.min != 'undefined' && typeof dailyTemps.max != 'undefined'){
                                                    innerTable.push('<th>low</th><th>high</th>')
                                                }
                                                innerTable.push('</tr></thead><tbody><tr>')
                                            }else{
                                                var innerTable = ['<table  class="iTable"><tbody><tr>']
                                            }
                                            let tempObject = {
                                                day : dailyTemps.day,
                                                eve : dailyTemps.eve,
                                                morn : dailyTemps.morn,
                                                night  : dailyTemps.night,
                                                low  : (dailyTemps.min ? dailyTemps.min : false),
                                                high : (dailyTemps.max ? dailyTemps.max : false),
                                            }
                                            for(let k2 in dailyTemps){
                                                //if(tempsI.indexOf(k2) > -1){
                                                      // day,min,max,night,eve,morn
                                                        // these are often listed out of order...
                                                        // appropriate order :
                                                if(dailyTemps[k2]){
                                                    let theTemp = kelvinToFahrenheit(dailyTemps[k2])
                                                    innerTable.push('<td style="background-color:'+d3ColorCodeTemp(theTemp)+'">'+  theTemp + '</td>')
                                                }
                                            }
                                            innerTable.push('</tr></tbody></table>')
                                            s+=innerTable.join('\n') + '</td>'
                                        }else{
                                            s += kelvinToFahrenheit(o[k])
                                            obj[k] = ''
                                            obj[k] = kelvinToFahrenheit(o[k])
                                        }
                                    }else if(k == 'weather'){
                                        // todo word images for current conditions
                                    }else{

                                         if(k == 'temp' || k == 'feels_like' || k == 'dew_point'){
                                            s +=("<td style='background-color:"+d3ColorCodeTemp(o[k])+";'>")
                                        }else if(k == 'wind_speed'){
                                            s +=("<td style='background-color:"+d3ColorCodeSimple(o[k])+";'>")
                                        }else if(k == 'clouds'){
                                            s +=("<td style='background-color:"+d3ColorCodeC(o[k])+";'>")
                                        }else if(k == 'humidity'){
                                            s +=("<td style='background-color:"+d3ColorCodeTemp(o[k])+";'>")
                                        }else if(k == 'pressure'){
                                            s += "<td style='background-color:"+d3ColorCodeP(o[k])+";'>"
                                        }else if(k == 'wind_deg'){
                                            s+=("<td style='background-color:"+d3ColorCodeDirection(o[k])+";'>"+o[k])
                                            //n.push("<td>"+obj[k2]+"</td>")
                                        }else if(o[k] != ''){
                                            s +=  '<td>'+o[k]
                                        }
                                    }
                                    //if(o[k] != ''){
                                        s+='</td>'
                                    //}
                                    currentDailyR.push(s)
                                }
                                currentDailyR.unshift('<tr>')
                                currentDailyR.push('</tr>')                                
                            })
                            writeToDom('openWeatherData2',currentDailyR.join('\n')+'</tbody></table>') 
                        }
                    }
                })
            }
            getTradeOgre = function(){
                let endPoint = '/tradeOgre'
                $.getJSON(endPoint,function(data){
                    if(typeof data == 'object' && data){
                        console.log(data)
                    }
                })
            }
            getHiveFlightsheets = function(){
                let endPoint = '/flightsheets'
                $.getJSON(endPoint,function(data){
                    if(typeof data == 'object' && data)
                    // assemble farm id/flightsheet id and name (if available)
                    var rows=[]
                    for(var farmId in data){
                        // FARM
                        let farm = data[farmId]
                        for(var fsId in farm){
                            // FLIGHTSHEET ID
                            let fs = farm[fsId]
                            let toShow = {
                                farmId:farmId,
                                id: fsId
                            }
                            if(typeof fs.name != 'undefined'){
                                toShow['name']=fs.name
                            }else{
                                toShow['name']='Untitled'
                            }
                            if(typeof fs['groups'] != 'undefined'){
                                // probably do stuff here for groups....
                                toShow['groups']=fs['groups']
                            }
                            rows.push(toShow)
                        }
                    }
                    if(rows.length>0){
                        let result=[]
                        rows.filter(function(r){
                            // use farmId+id for GUID
                            let guid = r.farmId+'-'+r.id
                            let line = '<tr id="'+guid+'"><td>'+r.name+'</td><td>'
                            // hightlight /move flightsheets in use to top
                            // show 'favored' flightsheets after active
                            // option to hide 'untitled' flightsheets
                            r.groups.filter(function(g){
                                var iLine = '<ul><li>'+g.coin+' - '+(g.miner_config.algo ? g.miner_config.algo :'')+'</li><li> '+( g.miner_config.user_config ?  g.miner_config.user_config :'ALL') +'</li><li><!--'+g.wal_id+'--></ul>'
                                line += iLine
                                // reform 'miner_conf:user_config' to only show devices
                                // co link wallet info prolly.... TODO
                            })
                            line+='</td>'
                            result.push(line)
                        })
                        writeToDom('hiveFlightsheets',result)
                        // attach click events
                    }
                })
            }
            getHiveData()
            getOpenWeather()
            // listen to changes initated by click handler
            setInterval(
                function(){
                    if(selectedCardIdxs.length > 0){
                        let sCardString = ['<ul>']
                        selectedCardIdxs.filter(function(c){
                            sCardString.push('<li>'+c+'</li>')
                        })
                        sCardString.push('</ul>')
                        sCardString.push('<table><tr><th>miner</th><th>Device String</th></tr>')
                        let miners = ['gminer','trex','cryptodredge']
                        miners.filter(function(miner){
                            var getP=getDeviceIndexPrefix(miner,selectedCardIdxs)
                            sCardString.push('<tr><td>'+miner+'</td><td>'  +getP+'</td></tr>')
                        })
                        sCardString.push('</table>')
                        writeToDom('hiveSelectedIdxs',sCardString.join(''))
                    }
                    if(selectedWorkerId  !== 0){
                        writeToDom('hiveSelectedWorkerId',selectedWorkerId)
                    }
                    if(selectedCard  != ''){
                        writeToDom('hiveSelectedCard',selectedCard)
                    }
                },1000
            )
            if(getData === true){
                dataInt = setInterval(function(){
                    getHiveData()
                },1000 * 10)
                dataInt2 = setInterval(function(){
                    getOpenWeather()
                },1000 * 60 * 5)
            }else{
                dataInt = false
                dataInt2 = false
            }
        </script>
	

    </body>
</html>